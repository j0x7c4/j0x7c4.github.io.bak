<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | 醉過方知酒濃]]></title>
  <link href="http://2naive.me/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://2naive.me/"/>
  <updated>2014-04-25T02:28:58+08:00</updated>
  <id>http://2naive.me/</id>
  <author>
    <name><![CDATA[Eli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[简单的iOS互动]]></title>
    <link href="http://2naive.me/blog/2014/02/01/begin-ios-develop/"/>
    <updated>2014-02-01T01:57:00+08:00</updated>
    <id>http://2naive.me/blog/2014/02/01/begin-ios-develop</id>
    <content type="html"><![CDATA[<p>最近想开发iOS上的app，却发现以前上课时学的iOS开发已经忘的差不多了，于是决定重拾objective-c，和iOS的开发。</p>

<p>我在看Beginning iOS 6 Development Exploring the iOS SDK 一书，这书有中文的翻译版，也翻译的不错，但还是看原版比较有感觉。实体书价格不菲，而且iOS7的版本也快出版了，觉得现在买一本iOS6的不太合适，所以还是在网上找了pdf，先看起来，等出了iOS7的版本后再买吧。</p>

<p><img src="http://img5.douban.com/lpic/s26815358.jpg"></p>

<p>iOS的开发也是MVC(Model-View-Controller)的框架，目前是个流行的开发框架。在Chapter 4中，作者介绍了如何构建简单的互动（通过按钮改变文字的内容）。其中提到了<code>Outlet</code>和<code>Action</code>两个东西，<code>Outlet</code>是controller中的对象，他会映射到view中的一个真实的元素。<code>Action</code>是controller的方法，他反映了view中一个元素的动作，就是说view中的某个元素触发了一个事件（比如按钮被按了一下），会执行相应的action方法。</p>

<p>创建view中的元素很方便，在storyboard中拖出一个UI元素来，然后按住<code>control</code>键，再拖动指针，拉到<code>xxController.h</code>中的interface中，就能选择是创建一个<code>Outlet</code>还是一个<code>Action</code>. 也可以事先在<code>xxController.h</code>中创建好相应的<code>Outlet</code>对象和<code>Action</code>方法，然后按住<code>control</code>，指针拖动到这些对象和方法上时，会自动高亮这些代码，放开指针，就能创建映射。不过我还是觉得先创建UI元素，再拖动指针自动创建<code>Outlet</code>或者<code>Action</code>比较方便。</p>

<p>在<code>xxController.h</code>中进行声明之后，可以在<code>xxController.m</code>中把代码实现。</p>

<p>``` objectivec BIDViewController.h
#import &lt;UIKit/UIKit.h&gt;</p>

<h1 id="ifndef-iboutlet">ifndef IBOutlet</h1>
<p>#define IBOutlet
#endif</p>

<p>@interface BIDViewController : UIViewController</p>

<p>@property (weak, nonatomic) IBOutlet UILabel *statusLabel;
- (IBAction)buttonPressed:(id)sender;</p>

<p>@end
```</p>

<p>``` objectivec BIDViewController.m
#import “BIDViewController.h”</p>

<p>@implementation BIDViewController</p>

<ul>
  <li>(IBAction)buttonPressed:(id)sender {
NSString *title = [sender titleForState:UIControlStateNormal];
NSString *text = [NSString stringWithFormat:@”%@ button pressed.”,title];
_statusLabel.text = text;
}
@end
```</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Octopress中使用LaTeX]]></title>
    <link href="http://2naive.me/blog/2013/12/26/add-latex/"/>
    <updated>2013-12-26T15:07:00+08:00</updated>
    <id>http://2naive.me/blog/2013/12/26/add-latex</id>
    <content type="html"><![CDATA[<p>在Octopress中显示LaTeX的方法，比想象中的要简单。只要几步，就能完成。</p>

<h2 id="headmathjax">在head中加入MathJax</h2>

<p>MathJax用来对LaTeX脚本进行渲染。</p>

<p>可以把下面的代码放到<code>source/_include/custom/head.html</code>中。</p>

<p><code>html
&lt;!-- mathjax config similar to math.stackexchange --&gt;
&lt;script type="text/x-mathjax-config"&gt;
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
&lt;/script&gt;
&lt;script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"&gt;&lt;/script&gt;
</code></p>

<h2 id="kramdownrdiscount">使用kramdown代替默认的rdiscount</h2>

<p>从网上的介绍来看，kramdown对于MathJax的支持要比rediscount好。</p>

<ul>
  <li>
    <p>在<code>Gemfile</code>中加入一行<code>gem 'kramdown'</code></p>
  </li>
  <li>
    <p>在<code>_config.yml</code>修改<code>markdown: kramdown</code></p>
  </li>
  <li>
    <p><code>bundle install</code></p>
  </li>
</ul>

<p>另外在使用上，kramdown的格式比rdiscount更加严谨，比如在插入code block时，必须严格的与上一行间隔一行。导致我又检查了一遍以前的文章，改了很多地方。</p>

<h2 id="sample">Sample</h2>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align*}
  & \phi(x,y) = \phi \left(\sum_{i=1}^n x_ie_i, \sum_{j=1}^n y_je_j \right)
  = \sum_{i=1}^n \sum_{j=1}^n x_i y_j \phi(e_i, e_j) = \\
  & (x_1, \ldots, x_n) \left( \begin{array}{ccc}
      \phi(e_1, e_1) & \cdots & \phi(e_1, e_n) \\
      \vdots & \ddots & \vdots \\
      \phi(e_n, e_1) & \cdots & \phi(e_n, e_n)
    \end{array} \right)
  \left( \begin{array}{c}
      y_1 \\
      \vdots \\
      y_n
    \end{array} \right)
\end{align*}
 %]]&gt;</script>

<p>上面的这些就是通过下面的LaTeX代码显示的：</p>

<p><code>latex
$$
\begin{align*}
  &amp; \phi(x,y) = \phi \left(\sum_{i=1}^n x_ie_i, \sum_{j=1}^n y_je_j \right)
  = \sum_{i=1}^n \sum_{j=1}^n x_i y_j \phi(e_i, e_j) = \\
  &amp; (x_1, \ldots, x_n) \left( \begin{array}{ccc}
      \phi(e_1, e_1) &amp; \cdots &amp; \phi(e_1, e_n) \\
      \vdots &amp; \ddots &amp; \vdots \\
      \phi(e_n, e_1) &amp; \cdots &amp; \phi(e_n, e_n)
    \end{array} \right)
  \left( \begin{array}{c}
      y_1 \\
      \vdots \\
      y_n
    \end{array} \right)
\end{align*}
$$
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开发Chrome插件中遇到的一些坑]]></title>
    <link href="http://2naive.me/blog/2013/12/23/my-first-chrome-extension/"/>
    <updated>2013-12-23T00:03:00+08:00</updated>
    <id>http://2naive.me/blog/2013/12/23/my-first-chrome-extension</id>
    <content type="html"><![CDATA[<p>前几天参加了一个hackthon, 在大约24小时的时间内，完成了一个chrome插件，插件扩展大众点评现有的一些功能，比如增加了街景视图，网页上的右键搜索菜单，和本地的点评商户收藏夹。具体可以自己使用看看，不过目前还没上架，可以下载源码来自己玩玩。<a href="https://github.com/j0x7c4/hackstreet">https://github.com/j0x7c4/hackstreet</a></p>

<p>以前没有太多JS的开发经验，这次开发是不断掉进坑里，然后再从坑里爬出来，直到最后有个完整版本出来。先说说chrome插件的配置文件吧，插件中有个叫<code>manifest.json</code>的文件，他管理了插件中所需的所有东西。</p>

<h2 id="hack">Hack现有网页的内容</h2>

<p>由于我们的插件需要修改大众点评网现有网页内容，比如在网页中插入我们的街景视图(我们的街景功能是用了腾讯街景的API). 这个就需要让<code>content_scripts</code>来做，他主要包括三个字段，<code>matches</code>, <code>css</code>, 和<code>js</code>. 只要把自己的JS文件名放到它的<code>js</code>字段中，一旦访问的URL符合规则，就会执行js中的脚本。例如：</p>

<p><code>json
"content_scripts": [ 
{
    "matches":["http://www.dianping.com/shop/*"],
    "css":["bootstrap.css"],
    "js":["hackit.js"]
}
]
</code></p>

<p>其中的CSS可以对自己添的内容制定样式。这个看似很简单，其实里面暗藏了一个大坑，不过也是因为自己太粗心，没有仔细看doc所导致的。由于我要在原有网页中嵌入一个街景视图，而街景视图用到了某企鹅的街景API，而那个API又必须是在线调用的。在普通的HTML中，要调用一个网上的脚本很方便，只需添加<code>&lt;script&gt;</code>标签，在<code>src</code>中指定脚本的URL。但是在chrome插件中，无法通过类似的方法，将脚本载入当前页面，并在插件的js脚本中调用。因为<code>content_scripts</code>中的脚本虽然可以访问当前页面的内容，但是无法调用当前页面中的js函数，这个在Chrome的开发文档中有提到：</p>

<blockquote>
  <p>However, content scripts have some limitations. They cannot:</p>

  <p>Use chrome.* APIs (except for parts of chrome.extension)</p>

  <p>Use variables or functions defined by their extension’s pages</p>

  <p>Use variables or functions defined by web pages or by other content scripts</p>
</blockquote>

<p><a href="http://developer.chrome.com/extensions/content_scripts.html">http://developer.chrome.com/extensions/content_scripts.html</a></p>

<p>因此只能把企鹅的js载到本地啦，然后再hack一下那个脚本，因为在本地调用需要做些修改。</p>

<h2 id="section">还有一些小东西</h2>

<p>开发chrome插件还有一些小东西可以分享一下，比如那个icon，文档中说最好是19x19的png图片，但如果真的把图片做成19x19，显示在浏览器中会比较糊（可能是因为我的retina屏幕）。其实把图片弄的大一点也是可以的，只要长宽比例是1:1就好。</p>

<p>如果在脚本中需要有一些跨域的请求，比如我将地址转化成经纬度时，是用到了google map的api, 我需要向<code>https://maps.googleapis.com/</code>发送请求，这就需要把<code>https://maps.googleapis.com/*</code>加入到<code>manifest.json</code>的<code>permissions</code>字段中。</p>

<p>还可以把一些公用的函数写在<code>background</code>的脚本中，然后通过message passing的方式去调用这些函数，不过具体效率还没测试过。在<code>background</code>中，可以直接使用<code>&lt;script&gt;</code>标签来添加在线的脚本。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[好用的sublime插件]]></title>
    <link href="http://2naive.me/blog/2013/12/11/todays-plugin-of-sublime/"/>
    <updated>2013-12-11T16:35:00+08:00</updated>
    <id>http://2naive.me/blog/2013/12/11/todays-plugin-of-sublime</id>
    <content type="html"><![CDATA[<p>今天尝试了3个很好用的sublime插件，在这里mark一下。这些插件都能在sublime的Package Control中找到，可以在线安装。</p>

<h2 id="sublimelinter">SublimeLinter</h2>

<p>经常用sublime写python和一些shell的脚本，有些地方写错了不太容易发现。这个插件可以自动检测一些格式上的错误。</p>

<h2 id="sidebarenhancements">SideBarEnhancements</h2>

<p>增强了sublime sidebar的功能，在sidebar上点右键能看到很多新的选项，谁用谁知道。</p>

<h2 id="filediffs">FileDiffs</h2>

<p>为sublime增加了diff的功能，真的很不错。直接在sidebar可以点右键选择需要比较的文件。</p>

<h2 id="sidebargit">SideBarGit</h2>

<p>在有git的目录下，能在sublime的状态栏中显示当前git的分支，虽然这个功能很平凡，但是提醒你当前的分支是很重要的，改code不要改错分支哦~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建能在天朝使用的web app]]></title>
    <link href="http://2naive.me/blog/2013/11/30/heroku-gae-python/"/>
    <updated>2013-11-30T20:23:00+08:00</updated>
    <id>http://2naive.me/blog/2013/11/30/heroku-gae-python</id>
    <content type="html"><![CDATA[<p>对于像我这种整天感觉很闲的人，总是会在代码中寻找自己的小世界，没事就写个web应用。可是身处天朝，资源有限。国际上很多知名的服务都不能用，比如某G的app engine. 不过还是有些漏网之鱼，没有完全被墙的。比如Heroku <a href="http://www.heroku.com">http://www.heroku.com</a>. (你现在看到的这个博客，就是放在heroku上的 &gt;_&lt; )</p>

<p>Heroku是通过git的方式将本地的代码部署到云上。前面讲到它没有完全被墙，因为放在它上面的app在国内是可以访问的，但是通过git部署的过程，是被墙的。所以我都是需要VPN才能将代码部署到heroku上。Heroku支持很多语言，我最常用的就是python了。刚刚用Django在Heroku上部署了一个web app. 可以参照下面这篇文章，在heroku上部署django <a href="https://devcenter.heroku.com/articles/getting-started-with-django">https://devcenter.heroku.com/articles/getting-started-with-django</a></p>

<p>如果在django中需要用到SESSION或者COOKIE的话，是需要使用heroku提供的数据库的。因为在heroku上程序无法在运行的时候创建静态文件，所以它们是变相的存储在数据库中的。数据库添加可以进入网站的dashboard，在add-on中添加一个免费的Heroku Postgresql. 免费的额度支持10MB的数据库(感觉有点小=_=).</p>

<!--more-->

<p><img src="https://addons.heroku.com/provider/addons/heroku-postgresql/icons/catalog.png"></p>

<p>于是乎，我就想到了GAE，它免费的数据库支持到了1GB. 虽然他上面的服务在天朝无法访问，但是如果请求是从heroku发出去的，然后heroku再就收GAE传回的数据显示在app上，就没问题了！带着这个想法，我在GAE上部署了一个数据库，用来存放一些数据，之前的文章中有提到如何在GAE上使用数据库。</p>

<h3 id="a-hrefhttp2naivemeblog20130531sql-like-at-gaegaesqla"><a href="http://2naive.me/blog/2013/05/31/SQL-like-at-GAE">在GAE上使用类SQL语句进行查询</a></h3>

<h3 id="a-hrefhttp2naivemeblog20130531database-at-gaegaedatabasea"><a href="http://2naive.me/blog/2013/05/31/database-at-GAE/">在GAE上使用Database</a></h3>

<p>下面这个例子是一张Inverted_index表中，存2个字段，并且实现两个方法去获取资料：</p>

<p>``` python
from google.appengine.ext import db</p>

<p>class Inverted_index ( db.Model ):
	id = db.IntegerProperty()
	word = db.StringProperty()</p>

<pre><code>def get (self,**kwargs):
	if not kwargs.keys():
		q = self.all()
		return [ {"id":item.id, "word":item.word } for item in q ]
	if 'ids' in kwargs:
		ids_set = ','.join(set(kwargs['ids']))
		q = db.GqlQuery("SELECT * FROM Inverted_index WHERE id in (%s)"%(ids_set))
		return dict(zip([int(item.id) for item in q],[item.word for item in q]))
	if 'words' in kwargs:
		words_set = ','.join(set(kwargs['words']))
		q = db.GqlQuery("SELECT * FROM Inverted_index WHERE word in (%s)"%(words_set))
		return dict(zip([item.word for item in q],[int(item.id) for item in q]))
	

def get_id_list_by_doc ( self, word_list ):
	word_to_id = self.get(words=word_list)
	return [word_to_id[word] for word in word_list] ```
</code></pre>

<h2 id="gae">另外介绍个可以部署在GAE的分词器</h2>

<p>这个分词器用纯python来写，网上看到很多人都推荐。</p>

<p><a href="https://github.com/fxsjy/jieba">https://github.com/fxsjy/jieba</a></p>

<p>但是部署在GAE上需要修改一个地方，不然可能会出错：
将<code>jieba</code>中的<code>__init__.py</code>的78-81行修改成这样。因为如果使用原来的系统临时文件夹来存放cache文件，会出错。于是我直接把存放cache的目录设置成当前目录。</p>

<p><code>python
if abs_path == os.path.join(_curpath,"dict.txt"): #defautl dictionary
    cache_file = os.path.join('.',"jieba.cache")
else: #customer dictionary
    cache_file = os.path.join('.',"jieba.user."+str(hash(abs_path))+".cache")
</code></p>

<p>在使用上，可以调用<code>jieba.cut</code>，也可以调用<code>jieba.finalseg.cut</code>，两者的区别还没仔细研究，但是如果在GAE上使用前者的话，会出现内存使用过大，然后被系统kill掉进程的问题。用后者就没问题了。具体例子如下：</p>

<p>``` python
import sys
import webapp2
from jieba import finalseg</p>

<p>class Segment(webapp2.RequestHandler):
    def get(self):
        text = self.request.get(‘text’)
        seg_list = finalseg.cut(text)
        text = ‘ ‘.join(seg_list)
        self.response.headers[‘Content-Type’] = ‘text/plain’
        self.response.write(text)</p>

<pre><code>def post(self):
    text = self.request.get('text')
    seg_list = finalseg.cut(text)
    text = ' '.join(seg_list)
    self.response.headers['Content-Type'] = 'text/plain'
    self.response.write(text)
</code></pre>

<p>app = webapp2.WSGIApplication([
    (‘/api/segment’, Segment),
    ],debug=True)
```</p>

<p>以上比较粗略的介绍了一下在网上利用免费资源搭建web app的方法。最近在鼓捣一个跟微博相关的东西，我就是利用了HEROKU和GAE来实现的。
###啊! 微博 <a href="http://rweibo.herokuapp.com/">http://rweibo.herokuapp.com/</a>
因为app还没上线，所以需要有将微博账号添加到app的测试账号中才能使用。想要尝试的话，可以私聊~</p>
]]></content>
  </entry>
  
</feed>
