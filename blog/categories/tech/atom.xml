<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | 醉過方知酒濃]]></title>
  <link href="http://2naive.me/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://2naive.me/"/>
  <updated>2014-04-25T18:37:01+08:00</updated>
  <id>http://2naive.me/</id>
  <author>
    <name><![CDATA[Eli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一台电脑中管理多个Octopress Blog]]></title>
    <link href="http://2naive.me/blog/2014/04/25/multi-octopress-deploy/"/>
    <updated>2014-04-25T16:51:00+08:00</updated>
    <id>http://2naive.me/blog/2014/04/25/multi-octopress-deploy</id>
    <content type="html"><![CDATA[<p>``` sh
if [ ! $1 ];
then
    echo “need role”
    exit 0
fi</p>

<p>private_key=’id_rsa<em>‘$1
public_key=’id_rsa</em>‘$1’.pub’</p>

<p>private_key_file=’/Users/jie/.ssh/’$private_key
public_key_file=’/Users/jie/.ssh/’$public_key</p>

<p>if [ -e $public_key_file ] &amp;&amp; [ -e $private_key_file ];
then
    cp $public_key_file ~/.ssh/id_rsa.pub
    cp $private_key_file ~/.ssh/id_rsa
    echo $1” changed”
else
    echo “Can’t find “$public_key_file” or “$private_key_file
fi
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简单的iOS互动]]></title>
    <link href="http://2naive.me/blog/2014/02/01/begin-ios-develop/"/>
    <updated>2014-02-01T01:57:00+08:00</updated>
    <id>http://2naive.me/blog/2014/02/01/begin-ios-develop</id>
    <content type="html"><![CDATA[<p>最近想开发iOS上的app，却发现以前上课时学的iOS开发已经忘的差不多了，于是决定重拾objective-c，和iOS的开发。</p>

<p>我在看Beginning iOS 6 Development Exploring the iOS SDK 一书，这书有中文的翻译版，也翻译的不错，但还是看原版比较有感觉。实体书价格不菲，而且iOS7的版本也快出版了，觉得现在买一本iOS6的不太合适，所以还是在网上找了pdf，先看起来，等出了iOS7的版本后再买吧。</p>

<p>{% img http://img5.douban.com/lpic/s26815358.jpg %}</p>

<p>iOS的开发也是MVC(Model-View-Controller)的框架，目前是个流行的开发框架。在Chapter 4中，作者介绍了如何构建简单的互动（通过按钮改变文字的内容）。其中提到了<code>Outlet</code>和<code>Action</code>两个东西，<code>Outlet</code>是controller中的对象，他会映射到view中的一个真实的元素。<code>Action</code>是controller的方法，他反映了view中一个元素的动作，就是说view中的某个元素触发了一个事件（比如按钮被按了一下），会执行相应的action方法。</p>

<p>创建view中的元素很方便，在storyboard中拖出一个UI元素来，然后按住<code>control</code>键，再拖动指针，拉到<code>xxController.h</code>中的interface中，就能选择是创建一个<code>Outlet</code>还是一个<code>Action</code>. 也可以事先在<code>xxController.h</code>中创建好相应的<code>Outlet</code>对象和<code>Action</code>方法，然后按住<code>control</code>，指针拖动到这些对象和方法上时，会自动高亮这些代码，放开指针，就能创建映射。不过我还是觉得先创建UI元素，再拖动指针自动创建<code>Outlet</code>或者<code>Action</code>比较方便。</p>

<p>在<code>xxController.h</code>中进行声明之后，可以在<code>xxController.m</code>中把代码实现。</p>

<p>``` objectivec BIDViewController.h
#import &lt;UIKit/UIKit.h&gt;</p>

<h1 id="ifndef-iboutlet">ifndef IBOutlet</h1>
<p>#define IBOutlet
#endif</p>

<p>@interface BIDViewController : UIViewController</p>

<p>@property (weak, nonatomic) IBOutlet UILabel *statusLabel;
- (IBAction)buttonPressed:(id)sender;</p>

<p>@end
```</p>

<p>``` objectivec BIDViewController.m
#import “BIDViewController.h”</p>

<p>@implementation BIDViewController</p>

<ul>
  <li>(IBAction)buttonPressed:(id)sender {
NSString *title = [sender titleForState:UIControlStateNormal];
NSString *text = [NSString stringWithFormat:@”%@ button pressed.”,title];
_statusLabel.text = text;
}
@end
```</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Octopress中使用LaTeX]]></title>
    <link href="http://2naive.me/blog/2013/12/26/add-latex/"/>
    <updated>2013-12-26T15:07:00+08:00</updated>
    <id>http://2naive.me/blog/2013/12/26/add-latex</id>
    <content type="html"><![CDATA[<p>在Octopress中显示LaTeX的方法，比想象中的要简单。只要几步，就能完成。</p>

<h2 id="headmathjax">在head中加入MathJax</h2>

<p>MathJax用来对LaTeX脚本进行渲染。</p>

<p>可以把下面的代码放到<code>source/_include/custom/head.html</code>中。</p>

<p><code>html
&lt;!-- mathjax config similar to math.stackexchange --&gt;
&lt;script type="text/x-mathjax-config"&gt;
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
&lt;/script&gt;
&lt;script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"&gt;&lt;/script&gt;
</code></p>

<h2 id="kramdownrdiscount">使用kramdown代替默认的rdiscount</h2>

<p>从网上的介绍来看，kramdown对于MathJax的支持要比rediscount好。</p>

<ul>
  <li>
    <p>在<code>Gemfile</code>中加入一行<code>gem 'kramdown'</code></p>
  </li>
  <li>
    <p>在<code>_config.yml</code>修改<code>markdown: kramdown</code></p>
  </li>
  <li>
    <p><code>bundle install</code></p>
  </li>
</ul>

<p>另外在使用上，kramdown的格式比rdiscount更加严谨，比如在插入code block时，必须严格的与上一行间隔一行。导致我又检查了一遍以前的文章，改了很多地方。</p>

<h2 id="sample">Sample</h2>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align*}
  & \phi(x,y) = \phi \left(\sum_{i=1}^n x_ie_i, \sum_{j=1}^n y_je_j \right)
  = \sum_{i=1}^n \sum_{j=1}^n x_i y_j \phi(e_i, e_j) = \\
  & (x_1, \ldots, x_n) \left( \begin{array}{ccc}
      \phi(e_1, e_1) & \cdots & \phi(e_1, e_n) \\
      \vdots & \ddots & \vdots \\
      \phi(e_n, e_1) & \cdots & \phi(e_n, e_n)
    \end{array} \right)
  \left( \begin{array}{c}
      y_1 \\
      \vdots \\
      y_n
    \end{array} \right)
\end{align*}
 %]]&gt;</script>

<p>上面的这些就是通过下面的LaTeX代码显示的：</p>

<p><code>latex
$$
\begin{align*}
  &amp; \phi(x,y) = \phi \left(\sum_{i=1}^n x_ie_i, \sum_{j=1}^n y_je_j \right)
  = \sum_{i=1}^n \sum_{j=1}^n x_i y_j \phi(e_i, e_j) = \\
  &amp; (x_1, \ldots, x_n) \left( \begin{array}{ccc}
      \phi(e_1, e_1) &amp; \cdots &amp; \phi(e_1, e_n) \\
      \vdots &amp; \ddots &amp; \vdots \\
      \phi(e_n, e_1) &amp; \cdots &amp; \phi(e_n, e_n)
    \end{array} \right)
  \left( \begin{array}{c}
      y_1 \\
      \vdots \\
      y_n
    \end{array} \right)
\end{align*}
$$
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开发Chrome插件中遇到的一些坑]]></title>
    <link href="http://2naive.me/blog/2013/12/23/my-first-chrome-extension/"/>
    <updated>2013-12-23T00:03:00+08:00</updated>
    <id>http://2naive.me/blog/2013/12/23/my-first-chrome-extension</id>
    <content type="html"><![CDATA[<p>前几天参加了一个hackthon, 在大约24小时的时间内，完成了一个chrome插件，插件扩展大众点评现有的一些功能，比如增加了街景视图，网页上的右键搜索菜单，和本地的点评商户收藏夹。具体可以自己使用看看，不过目前还没上架，可以下载源码来自己玩玩。<a href="https://github.com/j0x7c4/hackstreet">https://github.com/j0x7c4/hackstreet</a></p>

<p>以前没有太多JS的开发经验，这次开发是不断掉进坑里，然后再从坑里爬出来，直到最后有个完整版本出来。先说说chrome插件的配置文件吧，插件中有个叫<code>manifest.json</code>的文件，他管理了插件中所需的所有东西。</p>

<h2 id="hack">Hack现有网页的内容</h2>

<p>由于我们的插件需要修改大众点评网现有网页内容，比如在网页中插入我们的街景视图(我们的街景功能是用了腾讯街景的API). 这个就需要让<code>content_scripts</code>来做，他主要包括三个字段，<code>matches</code>, <code>css</code>, 和<code>js</code>. 只要把自己的JS文件名放到它的<code>js</code>字段中，一旦访问的URL符合规则，就会执行js中的脚本。例如：</p>

<p><code>json
"content_scripts": [ 
{
    "matches":["http://www.dianping.com/shop/*"],
    "css":["bootstrap.css"],
    "js":["hackit.js"]
}
]
</code></p>

<p>其中的CSS可以对自己添的内容制定样式。这个看似很简单，其实里面暗藏了一个大坑，不过也是因为自己太粗心，没有仔细看doc所导致的。由于我要在原有网页中嵌入一个街景视图，而街景视图用到了某企鹅的街景API，而那个API又必须是在线调用的。在普通的HTML中，要调用一个网上的脚本很方便，只需添加<code>&lt;script&gt;</code>标签，在<code>src</code>中指定脚本的URL。但是在chrome插件中，无法通过类似的方法，将脚本载入当前页面，并在插件的js脚本中调用。因为<code>content_scripts</code>中的脚本虽然可以访问当前页面的内容，但是无法调用当前页面中的js函数，这个在Chrome的开发文档中有提到：</p>

<blockquote>
  <p>However, content scripts have some limitations. They cannot:</p>

  <p>Use chrome.* APIs (except for parts of chrome.extension)</p>

  <p>Use variables or functions defined by their extension’s pages</p>

  <p>Use variables or functions defined by web pages or by other content scripts</p>
</blockquote>

<p><a href="http://developer.chrome.com/extensions/content_scripts.html">http://developer.chrome.com/extensions/content_scripts.html</a></p>

<p>因此只能把企鹅的js载到本地啦，然后再hack一下那个脚本，因为在本地调用需要做些修改。</p>

<h2 id="section">还有一些小东西</h2>

<p>开发chrome插件还有一些小东西可以分享一下，比如那个icon，文档中说最好是19x19的png图片，但如果真的把图片做成19x19，显示在浏览器中会比较糊（可能是因为我的retina屏幕）。其实把图片弄的大一点也是可以的，只要长宽比例是1:1就好。</p>

<p>如果在脚本中需要有一些跨域的请求，比如我将地址转化成经纬度时，是用到了google map的api, 我需要向<code>https://maps.googleapis.com/</code>发送请求，这就需要把<code>https://maps.googleapis.com/*</code>加入到<code>manifest.json</code>的<code>permissions</code>字段中。</p>

<p>还可以把一些公用的函数写在<code>background</code>的脚本中，然后通过message passing的方式去调用这些函数，不过具体效率还没测试过。在<code>background</code>中，可以直接使用<code>&lt;script&gt;</code>标签来添加在线的脚本。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[好用的sublime插件]]></title>
    <link href="http://2naive.me/blog/2013/12/11/todays-plugin-of-sublime/"/>
    <updated>2013-12-11T16:35:00+08:00</updated>
    <id>http://2naive.me/blog/2013/12/11/todays-plugin-of-sublime</id>
    <content type="html"><![CDATA[<p>今天尝试了3个很好用的sublime插件，在这里mark一下。这些插件都能在sublime的Package Control中找到，可以在线安装。</p>

<h2 id="sublimelinter">SublimeLinter</h2>

<p>经常用sublime写python和一些shell的脚本，有些地方写错了不太容易发现。这个插件可以自动检测一些格式上的错误。</p>

<h2 id="sidebarenhancements">SideBarEnhancements</h2>

<p>增强了sublime sidebar的功能，在sidebar上点右键能看到很多新的选项，谁用谁知道。</p>

<h2 id="filediffs">FileDiffs</h2>

<p>为sublime增加了diff的功能，真的很不错。直接在sidebar可以点右键选择需要比较的文件。</p>

<h2 id="sidebargit">SideBarGit</h2>

<p>在有git的目录下，能在sublime的状态栏中显示当前git的分支，虽然这个功能很平凡，但是提醒你当前的分支是很重要的，改code不要改错分支哦~</p>
]]></content>
  </entry>
  
</feed>
