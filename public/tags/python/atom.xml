<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Python | 醉過方知酒濃]]></title>
  <link href="http://yoursite.com/tags/python/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2013-10-05T00:26:04+08:00</updated>
  <id>http://yoursite.com/</id>
  <author>
    <name><![CDATA[Eli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HIVE中使用python实现UDF]]></title>
    <link href="http://yoursite.com/blog/2013/09/25/hive-python-udf/"/>
    <updated>2013-09-25T00:00:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/09/25/hive-python-udf</id>
    <content type="html"><![CDATA[<p>HIVE，FACEBOOK的一个开源项目，利用类SQL的语句（HiveQL）来加快一般的MapReduce的开发过程。</p>

<p>UDF，user defined function, 因为HIVE毕竟不是一般的关系型数据库，支持的HQL有限，如果要实现复杂的功能，就要通过自己定义函数来帮助实现。</p>

<p>HIVE应该利用PIPE的原理，将自己查询的结果放到python脚本的stdin中。所以他的查询结果不会显示在terminal中，terminal中显示的结果是python的执行结果。</p>

<p>使用HIVE的命令进入数据仓库(search)
<code>
use search;
</code>
使用HIVE的命令查看已经建立的表
<code>
show tables;
</code>
使用HIVE的命令查看xxx表中的字段
<code>
describe xxx;
</code>
使用HIVE命令用PYTHON实现UDF
<code>
add file udf.py;
SELECT
TRANSFORM(keyword)
USING 'python udf.py'
AS(keyword)
FROM xxx
WHERE dt='2013-09-25'
;
</code>
要注意的是，这里的TRANSFORM的内容可以写*，但是AS()里就不能写*，会报错。</p>

<p>输入到python中的内容，是按照AS里的数量来决定的。</p>

<p>下面是python的脚本，内容很简单，就是把输入的东西原封不动输出来。
``` python udf.py
import sys
for line in sys.stdin:</p>

<pre><code>line = line.strip()
print line
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenCV in Python]]></title>
    <link href="http://yoursite.com/blog/2013/07/20/opencv-in-python/"/>
    <updated>2013-07-20T00:00:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/07/20/opencv-in-python</id>
    <content type="html"><![CDATA[<p>OpenCV基本上每個學Computer Vision都用過，我之前也是用C++來使用OpenCV, 最近為了處理一些圖片轉影片，加Marker之類的簡單的操作，懶得再用C++去寫。於是就嘗試用Python來寫OpenCV.</p>

<p>在Python中使用OpenCV, 只要把OpenCV的Library加到Python的Lib目錄下面就可以了。</p>

<p>具體就是把OpenCV目錄下的”build/python/2.7/cv2.pyd" 複製到Python的“Lib/site-packages”目錄中。</p>

<p>OpenCV被包在cv2这个module中，在一开始加载这个module就可以了。</p>

<p>OpenCV中经常会用到cv::Size, cv::Point, 在python中就用tuple来代替，不用再定义cv::Size或者cv::Point. 比如原来C++中定义一个size用cv::Size(640,480), 现在Python中直接用(640,480)来代替就好了。</p>

<p>下面这个例子就是把image_dir中的图片转换成avi格式的影片
``` python
import sys
import os
import cv2
import re
def intCmp ( x,y ):</p>

<pre><code>a = re.search('([\d]+).png',x).group(1)
b = re.search('([\d]+).png',y).group(1)
return int(a)-int(b)
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>if len(sys.argv)&lt;3:
    print "Usage: %s (image_dir) (output)" %(sys.argv[0])
    exit(1)
image_dir = sys.argv[1]
output_file = sys.argv[2]
image_list = sorted(os.listdir(image_dir),cmp=intCmp)
video_writer = cv2.VideoWriter(output_file,-1,30,(640,480))
for image_file in image_list:
    print image_file
    img = cv2.imread("%s/%s"%(image_dir,image_file.strip()))
    cv2.imshow("rgb",img)
    key = cv2.waitKey(10)
    video_writer.write(img)
    if key == 27:
        break;
</code></pre>

<p>```
更多的细节可以看document</p>

<p><a href="http://docs.opencv.org/modules/refman.html"><a href="http://docs.opencv.org/modules/refman.html">http://docs.opencv.org/modules/refman.html</a></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python urllib+json 与web API交互]]></title>
    <link href="http://yoursite.com/blog/2013/06/01/python-urllibjson-webAPI/"/>
    <updated>2013-06-01T00:00:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/06/01/python-urllibjson-webAPI</id>
    <content type="html"><![CDATA[<p>目前的web app都流行用URL的方式传递Query, 然后接受server回传过来的json格式的结果。</p>

<p>利用python的urllib和json这两个模块，很容易就可以抓取里面的信息。
<code>python
import json
import urllib
url=URL_QUERY
f = urllib.urlopen(url)
j = json.loads(f.read())
</code>
f这个object存储了server回传的信息，通过<code>read()</code>将文字信息读出来。</p>

<p><code>loads()</code>将文字信息转成dictionary和list的形式，存储在j中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在GAE上使用Database]]></title>
    <link href="http://yoursite.com/blog/2013/05/31/database-at-GAE/"/>
    <updated>2013-05-31T00:00:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/05/31/database-at-GAE</id>
    <content type="html"><![CDATA[<p>很多应用都需要database的支持，GAE提供了不错的Database服务。</p>

<p>但是对于新手来讲，不是太容易理解GAE的database. GAE上的database称为datastore.</p>

<p>对于习惯于MySQL这种常见的SQL database的开发者来说，第一步当然是建立一个database, 然后又用户名，密码这些必要的东西。</p>

<p>但是对于GAE上的datastore来说，这些都不需要。在GAE上创建好的application, 就会分配到一个datastore, 免费quota 是有1GB的空间。至于用户名和密码，我目前还没发现在哪里需要验证，应该是在同一个application中就不需要验证了吧。</p>

<p>进入application的管理页面，在左边的column中能够看到Data那一栏，这个就是datastore的管理页面了。在Datastore Viewer里就能看到所有存储的data了。但是一开始里面是空的。</p>

<p>对于MySQL中table的概念，在GAE的datastore中是以Kind来表示。因为GAE是利用Google的Bigtable的感念，他没有像MySQL这样实际的table实体。</p>

<p>那一个Kind在code的层面上， 它是一个继承<code>db.Model class</code>的一个class.</p>

<p>以Python为例, 这是一个名叫Employee的class, 继承自db.Model. 也就是相当于MySQL中的一个<code>Employee table</code>：
```python
import datetime
from google.appengine.ext import db
class Employee(db.Model):</p>

<pre><code>first_name = db.StringProperty()
last_name = db.StringProperty()
hire_date = db.DateProperty()
attended_hr_training = db.BooleanProperty()
</code></pre>

<p><code>
其中</code>first_name<code>, </code>last_name<code>这些property, 就是相当于一般MySQL table中的每个column字段. 然后</code>db.StringProperty()```这就是定义字段的类型.</p>

<p>接下来,可以建立Employee class的instance, 然后给其中的property赋值. 最后使用<code>.put()</code>这个method就可以将数据存到datastore中了.
<code>python
employee = Employee(first_name='Antonio', last_name='Salieri')
employee.hire_date = datetime.datetime.now().date()
employee.attended_hr_training = True
employee.put()
</code>
以上是相当于SQL语句中的Insert语句。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在GAE上使用类SQL语句进行查询]]></title>
    <link href="http://yoursite.com/blog/2013/05/31/SQL-like-at-GAE/"/>
    <updated>2013-05-31T00:00:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/05/31/SQL-like-at-GAE</id>
    <content type="html"><![CDATA[<p>GAE上的Datastore虽然不是SQL的Database， 但是他提供了GQL语句进行类似SQL的查询。因为是类似SQL，所以不是完全等同于SQL语句。SQL语句中常用的count, group在GQL中就没有。</p>

<p>以下是GQL支持的格式，具体可以参见reference <a href="https://developers.google.com/appengine/docs/python/datastore/gqlreference" target="_blank"><a href="https://developers.google.com/appengine/docs/python/datastore/gqlreference">https://developers.google.com/appengine/docs/python/datastore/gqlreference</a></a>
```sql
SELECT [* | <property list> | <strong>key</strong>]
  [DISTINCT]
  [FROM <kind>]
  [WHERE <condition> [AND <condition> &hellip;]]
  [ORDER BY <property> [ASC | DESC] [, <property> [ASC | DESC] &hellip;]]
  [LIMIT [<offset>,]<count>]
  [OFFSET <offset>]</p>

<p>  <property list> := <property> [, <property> &hellip;]
  <condition> := <property> {&lt; | &lt;= | > | >= | = | != } <value>
  <condition> := <property> IN <list>
  <condition> := ANCESTOR IS <entity or key>
  <list> := (<value> [, <value> &hellip;]])
```</p>

<p>在Datastore 中有3种方式可以对数据进行查询：
```python
class Person(db.Model):</p>

<pre><code>first_name = db.StringProperty()
last_name = db.StringProperty()
city = db.StringProperty()
birth_year = db.IntegerProperty()
height = db.IntegerProperty()
</code></pre>

<h1>Query interface constructs a query using instance methods</h1>

<p>q = Person.all()
q.filter(&ldquo;last_name =&rdquo;, &ldquo;Smith&rdquo;)
q.filter(&ldquo;height &lt;=&rdquo;, max_height)
q.order(&ldquo;-height&rdquo;)</p>

<h1>GqlQuery interface constructs a query using a GQL query string</h1>

<p>q = db.GqlQuery(&ldquo;SELECT * FROM Person &rdquo; +</p>

<pre><code>            "WHERE last_name = :1 AND height &lt;= :2 " +
            "ORDER BY height DESC",
            "Smith", max_height)
</code></pre>

<h1>Query is not executed until results are accessed</h1>

<p>for p in q.run(limit=5):</p>

<pre><code>print "%s %s, %d inches tall" % (p.first_name, p.last_name, p.height)
</code></pre>

<p>```</p>

<p>个人感觉，还是GQL的方式比较直觉，用起来比较灵活。但是如果对于简单的数据查询，可能第一种方式更加有效, code会比较精简。</p>

<p>如果要在GQL中实现Group的功能，那就要分两步走。</p>

<p>按照上面那个例子，如果要把人按照城市来分组，那就要先把城市找出来，GQL就写成
```python
q = db.GqlQuery(&ldquo;SELECT DISTINCT city FROM Person&rdquo;)
result = []
for item in q:</p>

<pre><code>people = []
sq = db.GqlQuery("SELECT * FROM person WHERE city = '"+item.city+"'")
for item2 in sq:
    people.append({"first_name":item2.first_name,"second_name":item2.second_name})
    result.append({"city":item.city,"people":people})
</code></pre>

<p>```
这就是比较简单的GAE上的数据查询操作。</p>
]]></content>
  </entry>
  
</feed>
