<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | 醉過方知酒濃]]></title>
  <link href="http://yoursite.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2013-10-20T21:40:58+08:00</updated>
  <id>http://yoursite.com/</id>
  <author>
    <name><![CDATA[Eli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[试用networkx]]></title>
    <link href="http://yoursite.com/blog/2013/10/16/try-networkx/"/>
    <updated>2013-10-16T01:44:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/10/16/try-networkx</id>
    <content type="html"><![CDATA[<p>最近想用pagerank的方法来分析微博好友之间的权威关系，于是试着用crawler去抓微博上好友的信息，然后建立关系网络。在网上看到用networkx可以比较方便的建立关系网络，并且可以比较方便的用pagerank计算每个好友的重要性。</p>

<p>使用networks加入node和edge都很方便，并且networkx宣称他的node可以支持任何python的hashable的类型，于是我一开始使用custom的node.</p>

<p>```python
class user:</p>

<pre><code>def __init__(self,args):
    assert re.search('^[\d]+$',args['uid'])
    self.uid = args['uid']
    self.info = args
def __hash__(self):
    return int(self.uid)
</code></pre>

<p>```</p>

<p>可是这样写并不正确，他好像对自定义的类支持不太好（或许是不支持自定义类）。于是在网上查了好久，才看到要实现给一个node添加附加信息的方法。</p>

<p><a href="http://stackoverflow.com/questions/8490794/how-do-i-make-a-cutomised-object-as-a-node-for-networkx-and-how-do-i-look-it-up">http://stackoverflow.com/questions/8490794/how-do-i-make-a-cutomised-object-as-a-node-for-networkx-and-how-do-i-look-it-up</a></p>

<p>于是在加入node的时候，应该用
<code>python
G.add_node("label",foo="foo",bar="bar")
</code></p>

<p>于是把添加node改写成</p>

<p><code>python
G.add_node(user.uid,user.info)
</code>
添加node和edge是没问题了，结果在保存<code>gml</code>文件时又出问题了，里面的字符串竟然不支持utf-8… 官方是这么解释的：</p>

<blockquote><p>Notes</p>

<p>GML specifications indicate that the file should only use 7bit ASCII text encoding.iso8859-1 (latin-1).</p>

<p>This implementation does not support all Python data types as GML data. Nodes, node attributes, edge attributes, and graph attributes must be either dictionaries or single stings or numbers. If they are not an attempt is made to represent them as strings. For example, a list as edge data G[1][2][‘somedata’]=[1,2,3], will be
represented in the GML file as:</p>

<p><a href="http://networkx.lanl.gov/reference/generated/networkx.readwrite.gml.write_gml.html">http://networkx.lanl.gov/reference/generated/networkx.readwrite.gml.write_gml.html</a></p></blockquote>

<p>于是我只好抽取是ascii的编码的用户信息。然后把类的定义改写成：</p>

<p>``` python
class user:</p>

<pre><code>def __init__(self,args):

    assert re.search('^[\d]+$',args['uid'])

    self.uid = args['uid']
    self.info = {'uid':args['uid'],\
                 'n_follows':args['n_follows'],\
                 'n_fans':args['n_fans'],\
                 'n_weibos':args['n_weibos']}

def __hash__(self):
    return int(self.uid)
</code></pre>

<p>```</p>

<p>这样终于正常创建网络，读写gml文件了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature Selection in R is EASY!]]></title>
    <link href="http://yoursite.com/blog/2013/10/10/new-fselector-r/"/>
    <updated>2013-10-10T23:43:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/10/10/new-fselector-r</id>
    <content type="html"><![CDATA[<p>最早认识R语言是看到一本书叫做<i>&ldquo;Machine Learning for Hackers&rdquo;</i>, 听说R在machine learning的研究方面很有用处，就是一个专门为Machine Learning而生的语言，不过一直没用仔细研究过。在网上寻找Feature Selection方面的工具时，看到有人推荐R的package <a href=http://cran.r-project.org/web/packages/FSelector/FSelector.pdf>FSelector</a> . 于是就载下来尝试一下，结果发现真的很方便。</p>

<h4>R可以方便的使用现成的benchmark（比如<code>iris</code>），只要一句话就可以轻松导入数据！</h4>

<p>下面是一个简单的例子使用FSelector, 采用cvs来寻找feature的子集。其中第一个参数Species~表示数据集iris中的类别(label).</p>

<p><code>r
library(FSelector)
data(iris)
subset &lt;- cfs(Species~., iris)
f &lt;- as.simple.formula(subset, "Species")
print(f)
</code>
下面这个例子比较高阶，可以自己指定评价feature子集的好坏。采用best first search的策略来寻找子集。其中evaluator训练了rpart model，通过计算error rate来评价feature的好坏。</p>

<p>```r
library(FSelector)
library(rpart)
data(iris)
evaluator &lt;&ndash; function(subset) {
  #k-fold cross validation
  k &lt;&ndash; 5
  splits &lt;&ndash; runif(nrow(iris))
  results = sapply(1:k, function(i) {</p>

<pre><code>test.idx &lt;- (splits &gt;= (i - 1) / k) &amp; (splits &lt; i / k)
train.idx &lt;- !test.idx
test &lt;- iris[test.idx, , drop=FALSE]
train &lt;- iris[train.idx, , drop=FALSE]
tree &lt;- rpart(as.simple.formula(subset, "Species"), train)
error.rate = sum(test$Species != predict(tree, test, type="c")) / nrow(test)
return(1 - error.rate)
</code></pre>

<p>  })
  #print(subset)
  #print(mean(results))
  return(mean(results))
}
subset &lt;&ndash; best.first.search(names(iris)[-5], evaluator)
f &lt;&ndash; as.simple.formula(subset, &ldquo;Species&rdquo;)
print(f)
```</p>

<h3>iris</h3>

<p>This famous (Fisher&rsquo;s or Anderson&rsquo;s) iris data set gives the measurements in centimeters of the variables sepal length and width and petal length and width, respectively, for 50 flowers from each of 3 species of iris. The species are Iris setosa, versicolor, and virginica.</p>

<h3>cfs</h3>

<p>The algorithm finds attribute subset using correlation and entropy measures for continous and discrete data.</p>

<h2>Hints</h2>

<ul>
<li>虽然原生的R语言的IDE也不错用，但是发现一个更加强大的IDE，RStudio, 真是可以媲美matlab的IDE了。</li>
<li>R语言也可以在命令行中用batch的方式来运行，具体指令是<code>R CMD BATCH [options] infile [outfile]</code>, infile就是R的脚本文件，R的输出一般无法显示到STDOUT中，是以文件的形式存起来。如果没有指定outfile，就会以原文件名的方式来命名。在脚本执行的时候，很多无关紧要的内容也会被输出，可以使用options命令的<code>--slave</code>. 在最后的输出中，他也会很好心的帮你计算运行时间，如果不需要，也可以加<code>--no-timing</code>. 详见<a href="http://stat.ethz.ch/R-manual/R-devel/library/utils/html/BATCH.html">http://stat.ethz.ch/R-manual/R-devel/library/utils/html/BATCH.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在octopress中加入Google map]]></title>
    <link href="http://yoursite.com/blog/2013/10/07/google-map/"/>
    <updated>2013-10-07T02:21:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/10/07/google-map</id>
    <content type="html"><![CDATA[<h3>需要科学上网才能正常显示Google Map(API被墙了T_T)</h3>

<p>想在octopress中插入地图信息，考虑到之后可能会在博客中加入关于游记的文章，如果文章能有形象的地图信息会有很好的效果。于是在网上搜寻octopress的地图插件，发现一个叫做<a herf="http://mguentner.github.io/octolayer/">Octolayer</a>的插件，想载下来试试，不过github刚好出问题，我无法获取代码，再加上他不是用google map. 作为一个google的忠实脑残粉，我就决定自己写一个。</p>

<p>研究了一下<a href="https://developers.google.com/maps/documentation/javascript/">google map API</a>，发现难度并不大。就是在我的文章内容中加入一个div，然后用js去render. 照着sample code改了一下代码，主要是为了从div的属性中读取经纬度坐标。（需要jQuery）</p>

<p>``` javascript gmap.js
function initialize() {
  var lat = $(&ldquo;#map-canvas&rdquo;).attr(&ldquo;lat&rdquo;);
  var lng = $(&ldquo;#map-canvas&rdquo;).attr(&ldquo;lng&rdquo;);
  console.log(lat);
  console.log(lng);
  var loc = new google.maps.LatLng(lat,lng);
  var mapOptions = {</p>

<pre><code>zoom: 7,
center: loc,
mapTypeId: google.maps.MapTypeId.ROADMAP
</code></pre>

<p>  };</p>

<p>  map = new google.maps.Map(document.getElementById(&lsquo;map-canvas&rsquo;),</p>

<pre><code>  mapOptions);
</code></pre>

<p>  var marker = new google.maps.Marker({</p>

<pre><code>  position: loc,
  map: map,
  title: 'Hello World!'
</code></pre>

<p>  });</p>

<p>}</p>

<p>google.maps.event.addDomListener(window, &lsquo;load&rsquo;, initialize);
```</p>

<!--more-->


<p><b>但是上面的方法对于需要多个marker时会比较难处理，于是进行如下修改(10月7日下午修改)</b></p>

<p>``` javascript gmap.js
function initialize() {</p>

<p>  if (!$(&ldquo;div#map-canvas&rdquo;)[0]) return; //check there is map-canves</p>

<p>  var locations=[];</p>

<p>  //get locations from div.map-marker
  $(&ldquo;div.map-marker&rdquo;).each(function(){</p>

<pre><code>console.log($(this).attr('name'));
locations.push([$(this).attr('name'),$(this).attr('lat'),$(this).attr('lng')]);
</code></pre>

<p>  });</p>

<p>  var map = new google.maps.Map(document.getElementById(&lsquo;map-canvas&rsquo;), {</p>

<pre><code>  zoom: 10,
  center: new google.maps.LatLng(locations[0][1], locations[0][2]),
  mapTypeId: google.maps.MapTypeId.ROADMAP
});
</code></pre>

<p>  var infowindow = new google.maps.InfoWindow();</p>

<p>  for (i = 0; i &lt; locations.length; i++) {</p>

<pre><code>  marker = new google.maps.Marker({
    position: new google.maps.LatLng(locations[i][1], locations[i][2]),
    map: map
  });

  google.maps.event.addListener(marker, 'click', (function(marker, i) {
    return function() {
      infowindow.setContent(locations[i][0]);
      infowindow.open(map, marker);
    }
  })(marker, i));
</code></pre>

<p>  }
}</p>

<p>google.maps.event.addDomListener(window, &lsquo;load&rsquo;, initialize);</p>

<p>```</p>

<p>把<code>gmap.js</code>放在<code>source/javascripts</code>中，并且在<code>source/_includes/head.html</code>中加入下面几行：</p>

<p>``` html</p>

<script async="true" src="http://yoursite.com//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>


<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>


<script src="/javascripts/gmap.js"></script>


<p>```</p>

<p>如果已经在前面加过jQuery的话，就不用加第一行了。
然后在文章中，加入下面这段html代码。
其中div.map-marker用来传递每个marker的信息（lat和lng表示地点的经纬度，name表示marker的名字，这些是目前是需要自己输入的）; div#map-canvas用来最终显示地图。</p>

<p>``` html</p>

<div class="map-marker" lat="-33.890542" lng="151.274856" name = "BondiBeach" ></div>


<div class="map-marker" name = "CoogeeBeach" lat= "-33.923036" lng="151.259052"></div>


<div id="map-canvas"></div>


<p>```</p>

<p>我以为这样子应该能显示地图了，可是实际上却无法显示。这个问题我折腾了很久，最后才发现需要给div加css. 所以要在<code>source/stylesheets</code>中创建一个css样式文件（被HTML坑了）。</p>

<p>``` css gmap.css</p>

<h1>map-canvas { margin: 20px 0 20px 0; height: 300px;}</h1>

<p>```</p>

<p>所以在<code>source/_includes/head.html</code>中也要加入下面这行：</p>

<p><code>html
&lt;link href="http://yoursite.com/stylesheets/gmap.css" rel="stylesheet" type="text/css"&gt;
</code></p>

<p>这样子应该可以出现下面的结果了：</p>

<div class="map-marker" lat="-33.890542" lng="151.274856" name = "BondiBeach" ></div>


<div class="map-marker" name = "CoogeeBeach" lat= "-33.923036" lng="151.259052"></div>


<div id="map-canvas"></div>


<p>目前存在的问题是，因为都使用id叫map-canvas的div, 所以在同个页面中显示多个地图就会出错了。之后再想办法改进。又快天亮了，先睡了zzz</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[添加404页面]]></title>
    <link href="http://yoursite.com/blog/2013/10/02/add-404-page/"/>
    <updated>2013-10-02T23:48:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/10/02/add-404-page</id>
    <content type="html"><![CDATA[<p>今天给博客加了404页面，看起来感觉更加完整了一点。
加404页面的方法很简单，只要在<code>source</code>目录下面创建<code>404.html</code>文件，当发生404错误时，octopress就会自动跳转到<code>404.html</code>这个页面。
具体内容如下：</p>

<h2>```</h2>

<p>layout: page
title: Sorry，404错误！你要访问的网页不存在!</p>

<h2>footer: false</h2>

<p><code>
其中的</code>title```可以改成任何自己想要的内容。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从wordpress到octopress迁移成功]]></title>
    <link href="http://yoursite.com/blog/2013/10/01/cong-wordpressdao-octopressqian-yi-cheng-gong/"/>
    <updated>2013-10-01T23:49:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/10/01/cong-wordpressdao-octopressqian-yi-cheng-gong</id>
    <content type="html"><![CDATA[<p>忙活了一晚上，终于把原来wordpress的数据导入到了octopress中，心情不好的时候做些geek的事情转移一下注意力也不错，现在有点小开心。</p>

<p>我是参照下面这个链接介绍的方法，把原来wordpress的数据导出成xml文件，然后再用jekyll-import来转的。不过貌似转完之后还需要自己手动修改一些地方，比如代码高亮部分。幸好我之前的内容也不多，就小改了一下。
<a href=http://jekyllrb.com/docs/migrations/><a href="http://jekyllrb.com/docs/migrations/">http://jekyllrb.com/docs/migrations/</a></a></p>

<p>不过目前还有个问题，从wordpress转过来的文章，在超链接上还是有点问题，如果标题中有中文，转完后的文件名是unicode编码，之后会找不到超链接。于是我手动把那些文件名改成了英文，幸好文章不多，大概改了半小时改完了。</p>

<p>接下来要了解markdown语法啦，用这个写博客真的很酷！</p>
]]></content>
  </entry>
  
</feed>
