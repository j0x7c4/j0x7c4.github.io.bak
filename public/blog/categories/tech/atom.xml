<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | 醉過方知酒濃]]></title>
  <link href="http://yoursite.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2013-11-30T21:34:05+08:00</updated>
  <id>http://yoursite.com/</id>
  <author>
    <name><![CDATA[Eli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[搭建能在天朝使用的web app]]></title>
    <link href="http://yoursite.com/blog/2013/11/30/heroku-gae-python/"/>
    <updated>2013-11-30T20:23:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/11/30/heroku-gae-python</id>
    <content type="html"><![CDATA[<p>对于像我这种整天感觉很闲的人，总是会在代码中寻找自己的小世界，没事就写个web应用。可是身处天朝，资源有限。国际上很多知名的服务都不能用，比如某G的app engine. 不过还是有些漏网之鱼，没有完全被墙的。比如Heroku <a href="http://www.heroku.com">http://www.heroku.com</a>. (你现在看到的这个博客，就是放在heroku上的 >_&lt; )</p>

<p>Heroku是通过git的方式将本地的代码部署到云上。前面讲到它没有完全被墙，因为放在它上面的app在国内是可以访问的，但是通过git部署的过程，是被墙的。所以我都是需要VPN才能将代码部署到heroku上。Heroku支持很多语言，我最常用的就是python了。刚刚用Django在Heroku上部署了一个web app. 可以参照下面这篇文章，在heroku上部署django <a href="https://devcenter.heroku.com/articles/getting-started-with-django">https://devcenter.heroku.com/articles/getting-started-with-django</a></p>

<p>如果在django中需要用到SESSION或者COOKIE的话，是需要使用heroku提供的数据库的。因为在heroku上程序无法在运行的时候创建静态文件，所以它们是变相的存储在数据库中的。数据库添加可以进入网站的dashboard，在add-on中添加一个免费的Heroku Postgresql. 免费的额度支持10MB的数据库(感觉有点小=_=).</p>

<!--more-->


<p><img class="<a" src="href="https://addons.heroku.com/provider/addons/heroku-postgresql/icons/catalog.png">https://addons.heroku.com/provider/addons/heroku-postgresql/icons/catalog.png</a>"></p>

<p>于是乎，我就想到了GAE，它免费的数据库支持到了1GB. 虽然他上面的服务在天朝无法访问，但是如果请求是从heroku发出去的，然后heroku再就收GAE传回的数据显示在app上，就没问题了！带着这个想法，我在GAE上部署了一个数据库，用来存放一些数据，之前的文章中有提到如何在GAE上使用数据库。</p>

<h3><a href="http://yoursite.com/blog/2013/05/31/SQL-like-at-GAE">在GAE上使用类SQL语句进行查询</a></h3>

<h3><a href="http://yoursite.com/blog/2013/05/31/database-at-GAE/">在GAE上使用Database</a></h3>

<p>下面这个例子是一张Inverted_index表中，存2个字段，并且实现两个方法去获取资料：</p>

<p>``` python
from google.appengine.ext import db</p>

<p>class Inverted_index ( db.Model ):</p>

<pre><code>id = db.IntegerProperty()
word = db.StringProperty()

def get (self,**kwargs):
    if not kwargs.keys():
        q = self.all()
        return [ {"id":item.id, "word":item.word } for item in q ]
    if 'ids' in kwargs:
        ids_set = ','.join(set(kwargs['ids']))
        q = db.GqlQuery("SELECT * FROM Inverted_index WHERE id in (%s)"%(ids_set))
        return dict(zip([int(item.id) for item in q],[item.word for item in q]))
    if 'words' in kwargs:
        words_set = ','.join(set(kwargs['words']))
        q = db.GqlQuery("SELECT * FROM Inverted_index WHERE word in (%s)"%(words_set))
        return dict(zip([item.word for item in q],[int(item.id) for item in q]))


def get_id_list_by_doc ( self, word_list ):
    word_to_id = self.get(words=word_list)
    return [word_to_id[word] for word in word_list]
</code></pre>

<p>```</p>

<h2>另外介绍个可以部署在GAE的分词器</h2>

<p>这个分词器用纯python来写，网上看到很多人都推荐。</p>

<p><a href="https://github.com/fxsjy/jieba">https://github.com/fxsjy/jieba</a></p>

<p>但是部署在GAE上需要修改一个地方，不然可能会出错：
将<code>jieba</code>中的<code>__init__.py</code>的78-81行修改成这样。因为如果使用原来的系统临时文件夹来存放cache文件，会出错。于是我直接把存放cache的目录设置成当前目录。</p>

<p>``` python
if abs_path == os.path.join(_curpath,&ldquo;dict.txt&rdquo;): #defautl dictionary</p>

<pre><code>cache_file = os.path.join('.',"jieba.cache")
</code></pre>

<p>else: #customer dictionary</p>

<pre><code>cache_file = os.path.join('.',"jieba.user."+str(hash(abs_path))+".cache")
</code></pre>

<p>```</p>

<p>在使用上，可以调用<code>jieba.cut</code>，也可以调用<code>jieba.finalseg.cut</code>，两者的区别还没仔细研究，但是如果在GAE上使用前者的话，会出现内存使用过大，然后被系统kill掉进程的问题。用后者就没问题了。具体例子如下：</p>

<p>``` python
import sys
import webapp2
from jieba import finalseg</p>

<p>class Segment(webapp2.RequestHandler):</p>

<pre><code>def get(self):
    text = self.request.get('text')
    seg_list = finalseg.cut(text)
    text = ' '.join(seg_list)
    self.response.headers['Content-Type'] = 'text/plain'
    self.response.write(text)

def post(self):
    text = self.request.get('text')
    seg_list = finalseg.cut(text)
    text = ' '.join(seg_list)
    self.response.headers['Content-Type'] = 'text/plain'
    self.response.write(text)
</code></pre>

<p>app = webapp2.WSGIApplication([</p>

<pre><code>('/api/segment', Segment),
],debug=True)
</code></pre>

<p>```</p>

<p>以上比较粗略的介绍了一下在网上利用免费资源搭建web app的方法。最近在鼓捣一个跟微博相关的东西，我就是利用了HEROKU和GAE来实现的。</p>

<h3>啊! 微博 <a href="http://rweibo.herokuapp.com/">http://rweibo.herokuapp.com/</a></h3>

<p>因为app还没上线，所以需要有将微博账号添加到app的测试账号中才能使用。想要尝试的话，可以私聊~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Terminal中显示git的当前branch]]></title>
    <link href="http://yoursite.com/blog/2013/11/16/show-git-branch-name/"/>
    <updated>2013-11-16T01:05:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/11/16/show-git-branch-name</id>
    <content type="html"><![CDATA[<p>不知道有没有人和我有同样的困扰，在使用git的时候不小心改到了master分支上的代码，然后还不小心push了，结果还成功push了，而且自己还没发觉是push到了master上。如果代码正确还好，一旦代码有些问题就会引来很大麻烦。</p>

<p><img src="/images/blog/show-git-branch-name.png"></p>

<p>mac的terminal上并没有自带功能显示当前的分支，所以需要自己手动修改bash的显示方式。如图上所示，新建一个<code>qrl</code>的目录，初始化<code>git</code>，当<code>commit</code>之后会产生<code>.git</code>的目录，从<code>.git</code>中获取当前的分支名字。</p>

<p>实现起来比较容易，在.bash_profile中加入下面的代码就可以了。
``` bash
parse_git_branch() {</p>

<pre><code>git branch 2&gt; /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ [\1]/'
</code></pre>

<p>}
export PS1=&ldquo;\u@\h \W[\033[32m]\$(parse_git_branch)[\033[00m] $ &rdquo;
```</p>

<p>对于PS1的参数可以参考下面的来写</p>

<blockquote><p>\d ：代表日期</p>

<p>\H ：完整的主机名称</p>

<p>\h ：仅取主机的第一个名字</p>

<p>\t ：显示时间为24小时格式，如：HH：MM：SS</p>

<p>\T ：显示时间为12小时格式</p>

<p>\A ：显示时间为24小时格式：HH：MM</p>

<p>\u ：当前用户的账号名称</p>

<p>\v ：BASH的版本信息</p>

<p>\w ：完整的工作目录名称。家目录会以 ~代替</p>

<p>\W ：利用basename取得工作目录名称，所以只会列出最后一个目录</p>

<p>\# ：下达的第几个命令</p>

<p>\$ ：提示字符，如果是root时，提示符为：# ，普通用户则为：$</p></blockquote>

<h3>参考</h3>

<p><a href="http://martinfitzpatrick.name/article/add-git-branch-name-to-terminal-prompt-mac">http://martinfitzpatrick.name/article/add-git-branch-name-to-terminal-prompt-mac</a>
<a href="http://blog.sina.com.cn/s/blog_610913ea0100fce1.html">http://blog.sina.com.cn/s/blog_610913ea0100fce1.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sublime Text 备忘]]></title>
    <link href="http://yoursite.com/blog/2013/11/13/sublime-text2-tutorial/"/>
    <updated>2013-11-13T11:33:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/11/13/sublime-text2-tutorial</id>
    <content type="html"><![CDATA[<p>Sublime Text 是个很不错的文本编辑工具，已经使用1年多了。这里整理一些关于Sublime的使用方法，防止以后忘记。</p>

<h2>在线安装Package</h2>

<h3>安装Package Control</h3>

<ul>
<li>用 Ctrl+` 打开Console</li>
<li>在console中加入下面这段脚本</li>
</ul>


<p><code>python
import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())
</code></p>

<ul>
<li>重新打开sublime</li>
</ul>


<h3>用Package Control安装插件</h3>

<ul>
<li><code>Command+Shift+p</code>打开命令面板(如果非mac就用<code>Ctrl</code>代替<code>Command</code>)</li>
<li>输入<code>install</code>打开Install Package</li>
<li>选择需要的插件安装</li>
</ul>


<h3>添加Repository</h3>

<p>想要使用更多的插件，可以自行添加网上的repository，比如github.</p>

<ul>
<li><code>Command+Shift+p</code>打开命令面板</li>
<li>选择<code>package Control:Add Repository</code></li>
<li>然后在底下的Repository URL中填入github地址，比如<a href="https://github.com/freewizard/SublimeFormatSQL">https://github.com/freewizard/SublimeFormatSQL</a></li>
<li>最后再选择<code>install package</code>来安装插件</li>
</ul>


<h3>常用插件</h3>

<ul>
<li>SublimeFormatSQL <a href="https://github.com/freewizard/SublimeFormatSQL">https://github.com/freewizard/SublimeFormatSQL</a></li>
</ul>


<h3>备注</h3>

<ul>
<li>SublimeFormatSQL的最新版对Sublime Text 2的兼容性有点问题，我用朋友给的旧版本就可以了。具体issue参见<a href="https://github.com/freewizard/SublimeFormatSQL/issues/14">https://github.com/freewizard/SublimeFormatSQL/issues/14</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在hive中使用python来做UDF有点糟]]></title>
    <link href="http://yoursite.com/blog/2013/11/01/udf-in-python-sucks/"/>
    <updated>2013-11-01T23:57:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/11/01/udf-in-python-sucks</id>
    <content type="html"><![CDATA[<p>之前写了篇介绍如何在HIVE中用python来写UDF的文字，最近终于也开始需要用UDF来处理一些数据了。</p>

<p>可是现实和理想总是存在些差距，原本想着python简洁的代码和随改随用的特性，在UDF的灵活性上显得有点苍白无力。利用<code>TRANSFORM</code>, <code>USING</code>, <code>AS</code>的结构来把python的脚本当做UDF，虽然看起来非常方便，但实际用起来却有很大问题。</p>

<h2>无法单独处理某个字段</h2>

<p>没有仔细研究过这个具体的流程，不过猜想应该是从hive中select出来的数据以pipe的形式转到python的stdin中，再把python中的stdout的内容转到hive的输出中。这样如果仅需对选出的某个字段进行处理，其余字段不进行处理的话，必须在Python脚本中注意当前要处理的字段是第几个，一旦select中的顺序有所改变，那python脚本应该就无法处理了。目前仅选一个字段出来进行处理的情况比较少，大部分都是选出好几个字段来看。所以虽然python很好，不过我还是“十动然拒”了吧。</p>

<h2>无法外加聚集函数</h2>

<p>在使用中，下面这种格式是很死的。</p>

<p><code>sql
SELECT TRANSFORM(field_A, field_B) USING 'python foo.py' AS(field_AA, field_BB) FROM ...
</code></p>

<p>比如你想再对UDF外面加一层<code>Count</code>是没有办法实现的。某人会告诉你格式不对，无法运行。但是常规的用java写的UDF是没有问题的，全部都能hold住~</p>

<h2>外加的吐槽</h2>

<p>实际工作中，不仅仅需要<code>UDF</code>，<code>UDAF</code>和<code>UDTF</code>都是会经常遇到的。而Python拼死只能处理UDF的情况，对于后者只能呵呵了。于是反正UDAF和UDTF还是需要JAVA来写，那UDF也就顺便用JAVA写了吧。这样代码也统一一点，便于管理。</p>

<p>所以虽然python在UDF上的效果可以实现，不过功能太过简单，实际环境下还是很无力的。接下来还是用JAVA写<code>UDF</code>,<code>UDAF</code>和<code>UDTF</code>吧。回头吧，少年~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[试用networkx]]></title>
    <link href="http://yoursite.com/blog/2013/10/16/try-networkx/"/>
    <updated>2013-10-16T01:44:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/10/16/try-networkx</id>
    <content type="html"><![CDATA[<p>最近想用pagerank的方法来分析微博好友之间的权威关系，于是试着用crawler去抓微博上好友的信息，然后建立关系网络。在网上看到用networkx可以比较方便的建立关系网络，并且可以比较方便的用pagerank计算每个好友的重要性。</p>

<p>使用networks加入node和edge都很方便，并且networkx宣称他的node可以支持任何python的hashable的类型，于是我一开始使用custom的node.</p>

<p>```python
class user:</p>

<pre><code>def __init__(self,args):
    assert re.search('^[\d]+$',args['uid'])
    self.uid = args['uid']
    self.info = args
def __hash__(self):
    return int(self.uid)
</code></pre>

<p>```</p>

<p>可是这样写并不正确，他好像对自定义的类支持不太好（或许是不支持自定义类）。于是在网上查了好久，才看到要实现给一个node添加附加信息的方法。</p>

<p><a href="http://stackoverflow.com/questions/8490794/how-do-i-make-a-cutomised-object-as-a-node-for-networkx-and-how-do-i-look-it-up">http://stackoverflow.com/questions/8490794/how-do-i-make-a-cutomised-object-as-a-node-for-networkx-and-how-do-i-look-it-up</a></p>

<p>于是在加入node的时候，应该用
<code>python
G.add_node("label",foo="foo",bar="bar")
</code></p>

<p>于是把添加node改写成</p>

<p><code>python
G.add_node(user.uid,user.info)
</code>
添加node和edge是没问题了，结果在保存<code>gml</code>文件时又出问题了，里面的字符串竟然不支持utf-8… 官方是这么解释的：</p>

<blockquote><p>Notes</p>

<p>GML specifications indicate that the file should only use 7bit ASCII text encoding.iso8859-1 (latin-1).</p>

<p>This implementation does not support all Python data types as GML data. Nodes, node attributes, edge attributes, and graph attributes must be either dictionaries or single stings or numbers. If they are not an attempt is made to represent them as strings. For example, a list as edge data G[1][2][‘somedata’]=[1,2,3], will be
represented in the GML file as:</p>

<p><a href="http://networkx.lanl.gov/reference/generated/networkx.readwrite.gml.write_gml.html">http://networkx.lanl.gov/reference/generated/networkx.readwrite.gml.write_gml.html</a></p></blockquote>

<p>于是我只好抽取是ascii的编码的用户信息。然后把类的定义改写成：</p>

<p>``` python
class user:</p>

<pre><code>def __init__(self,args):

    assert re.search('^[\d]+$',args['uid'])

    self.uid = args['uid']
    self.info = {'uid':args['uid'],\
                 'n_follows':args['n_follows'],\
                 'n_fans':args['n_fans'],\
                 'n_weibos':args['n_weibos']}

def __hash__(self):
    return int(self.uid)
</code></pre>

<p>```</p>

<p>这样终于正常创建网络，读写gml文件了。</p>
]]></content>
  </entry>
  
</feed>
