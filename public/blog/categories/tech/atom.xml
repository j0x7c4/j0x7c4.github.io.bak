<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | 醉過方知酒濃]]></title>
  <link href="http://yoursite.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2013-11-16T18:50:01+08:00</updated>
  <id>http://yoursite.com/</id>
  <author>
    <name><![CDATA[Eli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在Terminal中显示git的当前branch]]></title>
    <link href="http://yoursite.com/blog/2013/11/16/show-git-branch-name/"/>
    <updated>2013-11-16T01:05:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/11/16/show-git-branch-name</id>
    <content type="html"><![CDATA[<p>不知道有没有人和我有同样的困扰，在使用git的时候不小心改到了master分支上的代码，然后还不小心push了，结果还成功push了，而且自己还没发觉是push到了master上。如果代码正确还好，一旦代码有些问题就会引来很大麻烦。</p>

<p><img src="images/blog/show-git-branch-name.png"></p>

<p>mac的terminal上并没有自带功能显示当前的分支，所以需要自己手动修改bash的显示方式。如图上所示，新建一个<code>qrl</code>的目录，初始化<code>git</code>，当<code>commit</code>之后会产生<code>.git</code>的目录，从<code>.git</code>中获取当前的分支名字。</p>

<p>实现起来比较容易，在.bash_profile中加入下面的代码就可以了。
``` bash
parse_git_branch() {</p>

<pre><code>git branch 2&gt; /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ [\1]/'
</code></pre>

<p>}
export PS1=&ldquo;\u@\h \W[\033[32m]\$(parse_git_branch)[\033[00m] $ &rdquo;
```</p>

<p>对于PS1的参数可以参考下面的来写</p>

<blockquote><p>\d ：代表日期</p>

<p>\H ：完整的主机名称</p>

<p>\h ：仅取主机的第一个名字</p>

<p>\t ：显示时间为24小时格式，如：HH：MM：SS</p>

<p>\T ：显示时间为12小时格式</p>

<p>\A ：显示时间为24小时格式：HH：MM</p>

<p>\u ：当前用户的账号名称</p>

<p>\v ：BASH的版本信息</p>

<p>\w ：完整的工作目录名称。家目录会以 ~代替</p>

<p>\W ：利用basename取得工作目录名称，所以只会列出最后一个目录</p>

<p>\# ：下达的第几个命令</p>

<p>\$ ：提示字符，如果是root时，提示符为：# ，普通用户则为：$</p></blockquote>

<h3>参考</h3>

<p><a href="http://martinfitzpatrick.name/article/add-git-branch-name-to-terminal-prompt-mac">http://martinfitzpatrick.name/article/add-git-branch-name-to-terminal-prompt-mac</a>
<a href="http://blog.sina.com.cn/s/blog_610913ea0100fce1.html">http://blog.sina.com.cn/s/blog_610913ea0100fce1.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sublime Text 备忘]]></title>
    <link href="http://yoursite.com/blog/2013/11/13/sublime-text2-tutorial/"/>
    <updated>2013-11-13T11:33:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/11/13/sublime-text2-tutorial</id>
    <content type="html"><![CDATA[<p>Sublime Text 是个很不错的文本编辑工具，已经使用1年多了。这里整理一些关于Sublime的使用方法，防止以后忘记。</p>

<h2>在线安装Package</h2>

<h3>安装Package Control</h3>

<ul>
<li>用 Ctrl+` 打开Console</li>
<li>在console中加入下面这段脚本</li>
</ul>


<p><code>python
import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())
</code></p>

<ul>
<li>重新打开sublime</li>
</ul>


<h3>用Package Control安装插件</h3>

<ul>
<li><code>Command+Shift+p</code>打开命令面板(如果非mac就用<code>Ctrl</code>代替<code>Command</code>)</li>
<li>输入<code>install</code>打开Install Package</li>
<li>选择需要的插件安装</li>
</ul>


<h3>添加Repository</h3>

<p>想要使用更多的插件，可以自行添加网上的repository，比如github.</p>

<ul>
<li><code>Command+Shift+p</code>打开命令面板</li>
<li>选择<code>package Control:Add Repository</code></li>
<li>然后在底下的Repository URL中填入github地址，比如<a href="https://github.com/freewizard/SublimeFormatSQL">https://github.com/freewizard/SublimeFormatSQL</a></li>
<li>最后再选择<code>install package</code>来安装插件</li>
</ul>


<h3>常用插件</h3>

<ul>
<li>SublimeFormatSQL <a href="https://github.com/freewizard/SublimeFormatSQL">https://github.com/freewizard/SublimeFormatSQL</a></li>
</ul>


<h3>备注</h3>

<ul>
<li>SublimeFormatSQL的最新版对Sublime Text 2的兼容性有点问题，我用朋友给的旧版本就可以了。具体issue参见<a href="https://github.com/freewizard/SublimeFormatSQL/issues/14">https://github.com/freewizard/SublimeFormatSQL/issues/14</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在hive中使用python来做UDF有点糟]]></title>
    <link href="http://yoursite.com/blog/2013/11/01/udf-in-python-sucks/"/>
    <updated>2013-11-01T23:57:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/11/01/udf-in-python-sucks</id>
    <content type="html"><![CDATA[<p>之前写了篇介绍如何在HIVE中用python来写UDF的文字，最近终于也开始需要用UDF来处理一些数据了。</p>

<p>可是现实和理想总是存在些差距，原本想着python简洁的代码和随改随用的特性，在UDF的灵活性上显得有点苍白无力。利用<code>TRANSFORM</code>, <code>USING</code>, <code>AS</code>的结构来把python的脚本当做UDF，虽然看起来非常方便，但实际用起来却有很大问题。</p>

<h2>无法单独处理某个字段</h2>

<p>没有仔细研究过这个具体的流程，不过猜想应该是从hive中select出来的数据以pipe的形式转到python的stdin中，再把python中的stdout的内容转到hive的输出中。这样如果仅需对选出的某个字段进行处理，其余字段不进行处理的话，必须在Python脚本中注意当前要处理的字段是第几个，一旦select中的顺序有所改变，那python脚本应该就无法处理了。目前仅选一个字段出来进行处理的情况比较少，大部分都是选出好几个字段来看。所以虽然python很好，不过我还是“十动然拒”了吧。</p>

<h2>无法外加聚集函数</h2>

<p>在使用中，下面这种格式是很死的。</p>

<p><code>sql
SELECT TRANSFORM(field_A, field_B) USING 'python foo.py' AS(field_AA, field_BB) FROM ...
</code></p>

<p>比如你想再对UDF外面加一层<code>Count</code>是没有办法实现的。某人会告诉你格式不对，无法运行。但是常规的用java写的UDF是没有问题的，全部都能hold住~</p>

<h2>外加的吐槽</h2>

<p>实际工作中，不仅仅需要<code>UDF</code>，<code>UDAF</code>和<code>UDTF</code>都是会经常遇到的。而Python拼死只能处理UDF的情况，对于后者只能呵呵了。于是反正UDAF和UDTF还是需要JAVA来写，那UDF也就顺便用JAVA写了吧。这样代码也统一一点，便于管理。</p>

<p>所以虽然python在UDF上的效果可以实现，不过功能太过简单，实际环境下还是很无力的。接下来还是用JAVA写<code>UDF</code>,<code>UDAF</code>和<code>UDTF</code>吧。回头吧，少年~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[试用networkx]]></title>
    <link href="http://yoursite.com/blog/2013/10/16/try-networkx/"/>
    <updated>2013-10-16T01:44:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/10/16/try-networkx</id>
    <content type="html"><![CDATA[<p>最近想用pagerank的方法来分析微博好友之间的权威关系，于是试着用crawler去抓微博上好友的信息，然后建立关系网络。在网上看到用networkx可以比较方便的建立关系网络，并且可以比较方便的用pagerank计算每个好友的重要性。</p>

<p>使用networks加入node和edge都很方便，并且networkx宣称他的node可以支持任何python的hashable的类型，于是我一开始使用custom的node.</p>

<p>```python
class user:</p>

<pre><code>def __init__(self,args):
    assert re.search('^[\d]+$',args['uid'])
    self.uid = args['uid']
    self.info = args
def __hash__(self):
    return int(self.uid)
</code></pre>

<p>```</p>

<p>可是这样写并不正确，他好像对自定义的类支持不太好（或许是不支持自定义类）。于是在网上查了好久，才看到要实现给一个node添加附加信息的方法。</p>

<p><a href="http://stackoverflow.com/questions/8490794/how-do-i-make-a-cutomised-object-as-a-node-for-networkx-and-how-do-i-look-it-up">http://stackoverflow.com/questions/8490794/how-do-i-make-a-cutomised-object-as-a-node-for-networkx-and-how-do-i-look-it-up</a></p>

<p>于是在加入node的时候，应该用
<code>python
G.add_node("label",foo="foo",bar="bar")
</code></p>

<p>于是把添加node改写成</p>

<p><code>python
G.add_node(user.uid,user.info)
</code>
添加node和edge是没问题了，结果在保存<code>gml</code>文件时又出问题了，里面的字符串竟然不支持utf-8… 官方是这么解释的：</p>

<blockquote><p>Notes</p>

<p>GML specifications indicate that the file should only use 7bit ASCII text encoding.iso8859-1 (latin-1).</p>

<p>This implementation does not support all Python data types as GML data. Nodes, node attributes, edge attributes, and graph attributes must be either dictionaries or single stings or numbers. If they are not an attempt is made to represent them as strings. For example, a list as edge data G[1][2][‘somedata’]=[1,2,3], will be
represented in the GML file as:</p>

<p><a href="http://networkx.lanl.gov/reference/generated/networkx.readwrite.gml.write_gml.html">http://networkx.lanl.gov/reference/generated/networkx.readwrite.gml.write_gml.html</a></p></blockquote>

<p>于是我只好抽取是ascii的编码的用户信息。然后把类的定义改写成：</p>

<p>``` python
class user:</p>

<pre><code>def __init__(self,args):

    assert re.search('^[\d]+$',args['uid'])

    self.uid = args['uid']
    self.info = {'uid':args['uid'],\
                 'n_follows':args['n_follows'],\
                 'n_fans':args['n_fans'],\
                 'n_weibos':args['n_weibos']}

def __hash__(self):
    return int(self.uid)
</code></pre>

<p>```</p>

<p>这样终于正常创建网络，读写gml文件了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature Selection in R is EASY!]]></title>
    <link href="http://yoursite.com/blog/2013/10/10/new-fselector-r/"/>
    <updated>2013-10-10T23:43:00+08:00</updated>
    <id>http://yoursite.com/blog/2013/10/10/new-fselector-r</id>
    <content type="html"><![CDATA[<p>最早认识R语言是看到一本书叫做<i>&ldquo;Machine Learning for Hackers&rdquo;</i>, 听说R在machine learning的研究方面很有用处，就是一个专门为Machine Learning而生的语言，不过一直没用仔细研究过。在网上寻找Feature Selection方面的工具时，看到有人推荐R的package <a href=http://cran.r-project.org/web/packages/FSelector/FSelector.pdf>FSelector</a> . 于是就载下来尝试一下，结果发现真的很方便。</p>

<h4>R可以方便的使用现成的benchmark（比如<code>iris</code>），只要一句话就可以轻松导入数据！</h4>

<p>下面是一个简单的例子使用FSelector, 采用cvs来寻找feature的子集。其中第一个参数Species~表示数据集iris中的类别(label).</p>

<p><code>r
library(FSelector)
data(iris)
subset &lt;- cfs(Species~., iris)
f &lt;- as.simple.formula(subset, "Species")
print(f)
</code>
下面这个例子比较高阶，可以自己指定评价feature子集的好坏。采用best first search的策略来寻找子集。其中evaluator训练了rpart model，通过计算error rate来评价feature的好坏。</p>

<p>```r
library(FSelector)
library(rpart)
data(iris)
evaluator &lt;&ndash; function(subset) {
  #k-fold cross validation
  k &lt;&ndash; 5
  splits &lt;&ndash; runif(nrow(iris))
  results = sapply(1:k, function(i) {</p>

<pre><code>test.idx &lt;- (splits &gt;= (i - 1) / k) &amp; (splits &lt; i / k)
train.idx &lt;- !test.idx
test &lt;- iris[test.idx, , drop=FALSE]
train &lt;- iris[train.idx, , drop=FALSE]
tree &lt;- rpart(as.simple.formula(subset, "Species"), train)
error.rate = sum(test$Species != predict(tree, test, type="c")) / nrow(test)
return(1 - error.rate)
</code></pre>

<p>  })
  #print(subset)
  #print(mean(results))
  return(mean(results))
}
subset &lt;&ndash; best.first.search(names(iris)[-5], evaluator)
f &lt;&ndash; as.simple.formula(subset, &ldquo;Species&rdquo;)
print(f)
```</p>

<h3>iris</h3>

<p>This famous (Fisher&rsquo;s or Anderson&rsquo;s) iris data set gives the measurements in centimeters of the variables sepal length and width and petal length and width, respectively, for 50 flowers from each of 3 species of iris. The species are Iris setosa, versicolor, and virginica.</p>

<h3>cfs</h3>

<p>The algorithm finds attribute subset using correlation and entropy measures for continous and discrete data.</p>

<h2>Hints</h2>

<ul>
<li>虽然原生的R语言的IDE也不错用，但是发现一个更加强大的IDE，RStudio, 真是可以媲美matlab的IDE了。</li>
<li>R语言也可以在命令行中用batch的方式来运行，具体指令是<code>R CMD BATCH [options] infile [outfile]</code>, infile就是R的脚本文件，R的输出一般无法显示到STDOUT中，是以文件的形式存起来。如果没有指定outfile，就会以原文件名的方式来命名。在脚本执行的时候，很多无关紧要的内容也会被输出，可以使用options命令的<code>--slave</code>. 在最后的输出中，他也会很好心的帮你计算运行时间，如果不需要，也可以加<code>--no-timing</code>. 详见<a href="http://stat.ethz.ch/R-manual/R-devel/library/utils/html/BATCH.html">http://stat.ethz.ch/R-manual/R-devel/library/utils/html/BATCH.html</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
